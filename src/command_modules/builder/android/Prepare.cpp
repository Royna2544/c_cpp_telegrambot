#include <absl/strings/strip.h>
#include <libxml/tree.h>

#include <filesystem>
#include <libxml2_helper.hpp>
#include <vector>

#include "ConfigParsers.hpp"
#include "RepoUtils.hpp"
#include "ForkAndRun.hpp"

namespace {

void initRecurseSubmodules(
    const std::filesystem::path &xmlFile) {
    auto trueKey = "true"_xmlChar;
    auto projectKey = "project"_xmlChar;
    auto pathKey = "path"_xmlChar;
    auto submoduleKey = "recurse_submodules"_xmlChar;
    libxml2_error_ctx ctx;

    xmlInitParser();
    xmlSetGenericErrorFunc(&ctx, libxml2_error_handler);
    xmlDoc *doc = xmlReadFile(xmlFile.string().c_str(), nullptr, 0);

    if (!doc) {
        LOG(ERROR) << "Failed to parse XML file.";
        xmlCleanupParser();
        return;
    }

    ForkAndRunShell shell;
    if (!shell.open()) {
	LOG(ERROR) << "Cannot open shell";
	return;
    }

    xmlNodePtr root = xmlDocGetRootElement(doc);
    for (xmlNodePtr cur = root->children; cur; cur = cur->next) {
        if (cur->type == XML_ELEMENT_NODE && cur->name == projectKey) {
            XmlCharWrapper path = xmlGetProp(cur, pathKey);
            XmlCharWrapper recurse = xmlGetProp(cur, submoduleKey);

            if (recurse == "true" && path) {
                LOG(INFO) << "Init submodules for: "
                           << path.str();
                shell << "(cd " << path.str() << "; git submodule update --init)" << ForkAndRunShell::endl;
            }
        }
    }
    shell.close().defuse();
    xmlFreeDoc(doc);
    xmlCleanupParser();
}

}  // namespace

bool ConfigParser::LocalManifest::GitPrepare::prepare(
    const std::filesystem::path &path) {
    if (!std::filesystem::exists(path)) {
        info.git_clone(path);
    } else {
        LOG(INFO) << "Local manifest exists already...";
        GitBranchSwitcher sl{path};
        if (sl.open() && sl.checkout(info)) {
            LOG(INFO) << "Repo is up-to-date.";
        } else {
            LOG(WARNING)
                << "Local manifest is not the correct repository, deleting it.";
            std::filesystem::remove_all(path);
            info.git_clone(path);
        }
    }
    if (!std::filesystem::exists(path)) {
        return false;
    }

    for (const auto &p : std::filesystem::directory_iterator(path)) {
        if (!p.is_regular_file() || p.path().extension() != ".xml") continue;
        initRecurseSubmodules(p.path());
    }
    return true;
}

bool ConfigParser::LocalManifest::WritePrepare::prepare(
    const std::filesystem::path &path) {
    if (!std::filesystem::exists(path)) {
        std::filesystem::create_directories(path);
    }
    auto *doc = xmlNewDoc(BAD_CAST "1.0");
    if (doc == nullptr) {
        LOG(ERROR) << "Failed to create XML document";
        return false;
    }
    auto *root = xmlNewNode(nullptr, BAD_CAST "manifest");
    xmlDocSetRootElement(doc, root);
    auto *comment =
        xmlNewDocComment(doc, BAD_CAST "Auto generated by c_cpp_telegrambot");
    xmlAddChild(root, comment);

    // Create a remote in local manifest
    constexpr std::string_view kGithubRemoteName = "cppbot_github";
    constexpr std::string_view kGithubUrl = "https://github.com/";
    xmlNodePtr remote = xmlNewChild(root, nullptr, BAD_CAST "remote", nullptr);
    xmlNewProp(remote, BAD_CAST "name", BAD_CAST kGithubRemoteName.data());
    xmlNewProp(remote, BAD_CAST "fetch", BAD_CAST kGithubUrl.data());

    // Create repo entries.
    for (const auto &repo : data) {
        xmlNodePtr repoNode =
            xmlNewChild(root, nullptr, BAD_CAST "project", nullptr);
        auto name = absl::StripPrefix(repo.url(), kGithubUrl);
        xmlNewProp(repoNode, BAD_CAST "name", BAD_CAST name.data());
        xmlNewProp(repoNode, BAD_CAST "path",
                   BAD_CAST repo.destination.c_str());
        xmlNewProp(repoNode, BAD_CAST "remote",
                   BAD_CAST kGithubRemoteName.data());
        xmlNewProp(repoNode, BAD_CAST "clone-depth", BAD_CAST "1");
        xmlNewProp(repoNode, BAD_CAST "revision",
                   BAD_CAST repo.branch().c_str());
    }

    // Save the XML file
    std::string xmlFilePath = path / "local_manifest.xml";
    xmlSaveFormatFileEnc(xmlFilePath.c_str(), doc, "UTF-8", 1);
    xmlFreeDoc(doc);
    return true;
}
