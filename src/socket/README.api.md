# TgBot Socket Protocol API Documentation

**Protocol Version**: 13  
**Endianness**: Little-endian (network byte order)  
**Alignment**: 8 bytes  
**Encryption**: AES-256-GCM  
**Authentication**: HMAC-SHA256

---

## Table of Contents

1. [Protocol Overview](#protocol-overview)
2. [Packet Structure](#packet-structure)
3. [Session Management](#session-management)
4. [Commands Reference](#commands-reference)
5. [Payload Formats](#payload-formats)
6. [Security Model](#security-model)
7. [Error Handling](#error-handling)
8. [Implementation Notes](#implementation-notes)

---

## Protocol Overview

The TgBot Socket Protocol is a secure, session-based communication protocol for client-server interactions with a Telegram bot.

### Key Features

- Strong encryption using AES-256-GCM for payload confidentiality and integrity
- Authentication via HMAC-SHA256 covering both header and encrypted payload
- Anti-replay protection through monotonic nonce validation
- Token-based session management with expiration
- Flexible payloads supporting Binary (packed structs) or JSON formats
- Cross-platform compatibility with automatic endianness handling

### Protocol Version History

| Version | Changes |
|---------|---------|
| 1 | Initial version |
| 2 | Added CRC32 checks to packet data |
| 3 | SHA256 checks, std::array conversions |
| 4 | Moved CMD_UPLOAD_FILE_DRY to internal namespace |
| 5 | Used packed attribute for structs |
| 6 | Separate callback for CMD_UPLOAD_FILE_DRY_CALLBACK |
| 7 | Removed packed attribute, aligned all as 8 bytes |
| 8 | Changed checksum to uint64_t |
| 9 | Removed padding objects |
| 10 | Python compliance fixes, added INVALID_CMD |
| 11 | Removed CMD_DELETE_CONTROLLER_BY_ID, added payload type |
| 12 | OpenSSL HMAC + AES-GCM + nonces + session-based encryption |
| 13 | HMAC covers header, moved to end of packet (CURRENT) |

---

## Packet Structure

### Wire Format Overview

Every packet consists of three sequential parts:

1. **Header** - Fixed 80 bytes containing metadata
2. **Encrypted Payload** - Variable length encrypted data with 16-byte GCM tag
3. **HMAC** - 32 bytes authenticating header and encrypted payload

### Packet Header Fields

| Field | Type | Size | Description |
|-------|------|------|-------------|
| magic | int64_t | 8 bytes | Protocol validator: 0xDEADFACE + 13 = 0xDEADFADB |
| cmd | Command enum | 4 bytes | Command to execute |
| data_type | PayloadType enum | 4 bytes | 0=Binary struct, 1=JSON string |
| data_size | uint32_t | 4 bytes | Length of encrypted payload in bytes |
| session_token | char array | 32 bytes | Session key for HMAC and encryption |
| nonce | uint64_t | 8 bytes | Timestamp milliseconds + random for replay protection |
| init_vector | uint8_t array | 12 bytes | Random IV for AES-256-GCM, generated per-packet |
| (padding) | - | 8 bytes | Alignment padding to reach 80 bytes |

**Total Header Size**: 80 bytes

### ByteHelper Wrapper

All integer and enum fields use ByteHelper template for automatic endianness conversion. On little-endian systems (x86), values are byte-swapped to network byte order. On big-endian systems, no conversion occurs. This ensures consistent little-endian wire format across all platforms.

### Payload Encryption

The payload section contains:
- Original data (plaintext before encryption)
- 16-byte GCM authentication tag appended after encryption

The data_size field in the header reflects the total encrypted size including the tag.

### HMAC Authentication

A 32-byte HMAC-SHA256 follows the encrypted payload. The HMAC is computed over:
1. Complete 80-byte header
2. Complete encrypted payload (including GCM tag)

This authenticates the entire packet structure.

---

## Session Management

All commands except session establishment require a valid session token.

### Session Lifecycle Flow

**Step 1: Client Requests Session**

Direction: Client to Server  
Command: CMD_OPEN_SESSION  
Payload: None or JSON with client information  
Authentication: None (HMAC field contains zeros)

**Step 2: Server Creates Session**

Direction: Server to Client  
Command: CMD_OPEN_SESSION_ACK  
Payload: JSON containing session_token and expiration_time  
Token: 32-byte random string generated by server  
Default Expiration: 1 hour from creation

**Step 3: Authenticated Communication**

All subsequent commands include the session token in the header. Server validates:
- Token exists in active sessions table
- Token has not expired
- Nonce is greater than last received nonce (anti-replay)

**Step 4: Session Termination**

Direction: Client to Server  
Command: CMD_CLOSE_SESSION  
Payload: None  
Effect: Server removes session from table, token becomes invalid

### Session Security

**Token Generation**: 32 bytes of cryptographically random data

**Nonce Validation**: Server tracks last nonce per session. If received nonce is less than or equal to last nonce, packet is rejected as replay attack.

**Expiration Enforcement**: Server checks expiration on every packet. Expired sessions are removed and packets rejected.

**Token Storage**: Client must store token securely and include in all packet headers.

---

## Commands Reference

### Command Categories

| Category | Command Group |
|----------|---------------|
| Session | CMD_OPEN_SESSION, CMD_OPEN_SESSION_ACK, CMD_CLOSE_SESSION |
| Messaging | CMD_WRITE_MSG_TO_CHAT_ID |
| Chat Control | CMD_OBSERVE_CHAT_ID, CMD_OBSERVE_ALL_CHATS |
| File Transfer | CMD_SEND_FILE_TO_CHAT_ID, CMD_TRANSFER_FILE, CMD_TRANSFER_FILE_REQUEST |
| Chunked Transfer | CMD_TRANSFER_FILE_BEGIN, CMD_TRANSFER_FILE_CHUNK, CMD_TRANSFER_FILE_CHUNK_RESPONSE, CMD_TRANSFER_FILE_END |
| System | CMD_GET_UPTIME, CMD_CTRL_SPAMBLOCK |
| Callbacks | CMD_GET_UPTIME_CALLBACK, CMD_GENERIC_ACK |

### Command Enumeration

**Client Commands (1-99)**

| Value | Name | Purpose |
|-------|------|---------|
| 0 | CMD_INVALID | Invalid command indicator |
| 1 | CMD_WRITE_MSG_TO_CHAT_ID | Send text message to chat |
| 2 | CMD_CTRL_SPAMBLOCK | Configure spam blocking |
| 3 | CMD_OBSERVE_CHAT_ID | Monitor specific chat |
| 4 | CMD_SEND_FILE_TO_CHAT_ID | Send file/media to chat |
| 5 | CMD_OBSERVE_ALL_CHATS | Monitor all chats globally |
| 6 | CMD_GET_UPTIME | Query server uptime |
| 7 | CMD_TRANSFER_FILE | Transfer file with verification |
| 8 | CMD_TRANSFER_FILE_REQUEST | Request file from server |

**Server Internal Commands (100+)**

| Value | Name | Purpose |
|-------|------|---------|
| 100 | CMD_GET_UPTIME_CALLBACK | Return uptime information |
| 101 | CMD_GENERIC_ACK | Generic success/failure response |
| 102 | CMD_OPEN_SESSION | Session establishment request |
| 103 | CMD_OPEN_SESSION_ACK | Session establishment response |
| 104 | CMD_CLOSE_SESSION | Session termination request |
| 105 | CMD_TRANSFER_FILE_BEGIN | Start chunked transfer session |
| 106 | CMD_TRANSFER_FILE_CHUNK | Send file chunk in multi-part transfer |
| 107 | CMD_TRANSFER_FILE_CHUNK_RESPONSE | Acknowledge chunk receipt |
| 108 | CMD_TRANSFER_FILE_END | Complete chunked transfer session |

**Note**: Chunked transfer commands (105-108) are internal protocol commands used by the server for managing large file transfers. Clients should use CMD_TRANSFER_FILE or CMD_TRANSFER_FILE_REQUEST instead.

---

## Payload Formats

### PayloadType Enumeration

| Value | Name | Description |
|-------|------|-------------|
| 0 | Binary | Packed C++ structures with fixed sizes |
| 1 | Json | UTF-8 JSON strings with flexible schema |

---

### CMD_WRITE_MSG_TO_CHAT_ID

**Purpose**: Send text message to Telegram chat  
**Direction**: Client to Server  
**Response**: CMD_GENERIC_ACK

**Binary Format - WriteMsgToChatId struct (264 bytes)**

| Field | Type | Size | Description |
|-------|------|------|-------------|
| chat | int64_t | 8 bytes | Telegram chat ID (can be negative for groups) |
| message | char array | 256 bytes | Null-terminated message text |

**JSON Format Fields**

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| chat | integer | Yes | Telegram chat ID |
| message | string | Yes | Message text to send |

**JSON Example**

Field chat: -1001234567890  
Field message: Bot is online and operational

---

### CMD_OBSERVE_CHAT_ID

**Purpose**: Enable or disable message observation for specific chat  
**Direction**: Client to Server  
**Response**: CMD_GENERIC_ACK

**Binary Format - ObserveChatId struct (16 bytes)**

| Field | Type | Size | Description |
|-------|------|------|-------------|
| chat | int64_t | 8 bytes | Chat ID to observe |
| observe | bool | 1 byte | true=start observing, false=stop observing |
| (padding) | - | 7 bytes | Alignment padding |

**JSON Format Fields**

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| chat | integer | Yes | Chat ID to observe |
| observe | boolean | Yes | Observation state |

**Notes**: When observing, bot logs and processes all messages from that chat. Mutually exclusive with CMD_OBSERVE_ALL_CHATS.

---

### CMD_OBSERVE_ALL_CHATS

**Purpose**: Enable or disable observation for all chats globally  
**Direction**: Client to Server  
**Response**: CMD_GENERIC_ACK

**Binary Format - ObserveAllChats struct (8 bytes)**

| Field | Type | Size | Description |
|-------|------|------|-------------|
| observe | bool | 1 byte | true=observe all chats, false=stop observing |
| (padding) | - | 7 bytes | Alignment padding |

**JSON Format Fields**

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| observe | boolean | Yes | Global observation state |

**Notes**: Overrides individual chat observations. Generates high logging volume when enabled.

---

### CMD_SEND_FILE_TO_CHAT_ID

**Purpose**: Send file or media to Telegram chat in single operation  
**Direction**: Client to Server  
**Response**: CMD_GENERIC_ACK

**FileType Enumeration**

| Value | Name | Description |
|-------|------|-------------|
| 0 | TYPE_PHOTO | Image file |
| 1 | TYPE_VIDEO | Video file |
| 2 | TYPE_GIF | Animated GIF |
| 3 | TYPE_DOCUMENT | Generic document |
| 4 | TYPE_DICE | Dice emoji (no file) |
| 5 | TYPE_STICKER | Sticker image |

**Binary Format - SendFileToChatId struct (272 bytes)**

| Field | Type | Size | Description |
|-------|------|------|-------------|
| chat | int64_t | 8 bytes | Destination chat ID |
| fileType | FileType enum | 4 bytes | Type of file to send |
| filePath | char array | 256 bytes | Local path or Telegram file_id |
| (padding) | - | 4 bytes | Alignment padding |

**JSON Format Fields**

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| chat | integer | Yes | Destination chat ID |
| fileType | integer | Yes | FileType enum value |
| filePath | string | Yes | File path or file_id |

**File Path Options**

- Local filesystem path on server: /tmp/document.pdf
- Telegram file_id for reuse: AgACAgIAAxkBAAIC...
- Ignored for TYPE_DICE

---

### CMD_TRANSFER_FILE and CMD_TRANSFER_FILE_REQUEST

**Purpose**: Transfer file with hash verification and optional overwrite control  
**Direction**: Client to Server for push, Server to Client for request  
**Response**: CMD_GENERIC_ACK or CMD_TRANSFER_FILE (for requests)

**Binary Format - FileTransferMeta struct (552 bytes)**

| Field | Type | Size | Description |
|-------|------|------|-------------|
| srcfilepath | char array | 256 bytes | Source path (reference only) |
| destfilepath | char array | 256 bytes | Destination path |
| sha256_hash | uint8_t array | 32 bytes | Expected SHA256 file hash |
| options.overwrite | bool | 1 byte | Allow overwriting existing file |
| options.hash_ignore | bool | 1 byte | Skip hash verification |
| options.dry_run | bool | 1 byte | Check only, do not transfer |
| (padding) | - | 5 bytes | Alignment padding |

Total struct size: 552 bytes. File data follows immediately after struct (if not dry_run).

**JSON Format Fields**

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| srcfilepath | string | Yes | Source file path |
| destfilepath | string | Yes | Destination path |
| hash | string | Conditional | Hex-encoded SHA256 (required if hash_ignore=false) |
| options.overwrite | boolean | No | Allow overwriting (default: false) |
| options.hash_ignore | boolean | No | Skip hash check (default: false) |
| options.dry_run | boolean | No | Check only (default: false) |

**JSON with Binary Data Format**

For JSON payloads with file data:
1. JSON metadata object
2. Single 0xFF byte separator
3. Raw file bytes

**Transfer Options Behavior**

**dry_run = true**: Server checks if file exists and compares hash if available. Returns success/failure without transferring data.

**hash_ignore = true**: Server accepts file without verifying hash. Useful when hash is unknown or file content may vary.

**overwrite = false**: Server rejects transfer if destination file already exists. Returns ERROR_COMMAND_IGNORED.

**overwrite = true**: Server replaces existing file with transferred data.

---

### CMD_GET_UPTIME

**Purpose**: Query server uptime statistics  
**Direction**: Client to Server  
**Response**: CMD_GET_UPTIME_CALLBACK  
**Request Payload**: None

**Binary Response - GetUptimeCallback struct (24 bytes)**

| Field | Type | Size | Description |
|-------|------|------|-------------|
| uptime | char array | 24 bytes | Formatted uptime string |

Format: "Uptime: 999h 99m 99s" with null termination

**JSON Response Fields**

| Field | Type | Description |
|-------|------|-------------|
| start_time | string | Server start timestamp |
| current_time | string | Current server timestamp |
| uptime | string | Human-readable uptime duration |

---

### CMD_CTRL_SPAMBLOCK

**Purpose**: Configure spam blocking behavior  
**Direction**: Client to Server  
**Response**: CMD_GENERIC_ACK

**CtrlSpamBlock Enumeration**

| Value | Name | Description |
|-------|------|-------------|
| 0 | OFF | Spam blocking disabled |
| 1 | LOGGING_ONLY | Log spam but take no action |
| 2 | PURGE | Delete spam messages only |
| 3 | PURGE_AND_MUTE | Delete messages and mute sender |

**Binary Format**: Single 4-byte enum value

**JSON Format Fields**

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| mode | integer | Yes | CtrlSpamBlock enum value |

---

### CMD_GENERIC_ACK

**Purpose**: Generic acknowledgement for command success or failure  
**Direction**: Server to Client

**AckType Enumeration**

| Value | Name | Meaning |
|-------|------|---------|
| 0 | SUCCESS | Command completed successfully |
| 1 | ERROR_TGAPI_EXCEPTION | Telegram API rejected request |
| 2 | ERROR_INVALID_ARGUMENT | Invalid command parameters |
| 3 | ERROR_COMMAND_IGNORED | Command rejected by policy |
| 4 | ERROR_RUNTIME_ERROR | Internal server error occurred |
| 5 | ERROR_CLIENT_ERROR | Client protocol violation |

**Binary Format - GenericAck struct (264 bytes)**

| Field | Type | Size | Description |
|-------|------|------|-------------|
| result | AckType enum | 4 bytes | Result type |
| error_msg | char array | 256 bytes | Error description (empty for SUCCESS) |
| (padding) | - | 4 bytes | Alignment padding |

**JSON Format - Success**

| Field | Type | Value |
|-------|------|-------|
| result | boolean | true |

**JSON Format - Failure**

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| result | boolean | Yes | Always false for errors |
| error_type | string | Yes | Error category name |
| error_msg | string | Yes | Human-readable error description |

**Error Type Strings**

- TGAPI_EXCEPTION: Telegram API error (invalid chat, permissions, etc.)
- INVALID_ARGUMENT: Malformed parameters or wrong data structure
- COMMAND_IGNORED: Policy rejection (file exists, already observing, etc.)
- RUNTIME_ERROR: Server internal error (I/O failure, out of memory)
- CLIENT_ERROR: Protocol violation (expired session, replay attack)

---

## Security Model

### AES-256-GCM Encryption

**Algorithm**: Advanced Encryption Standard with 256-bit key in Galois/Counter Mode

**Key Source**: 32-byte session_token from header

**Initialization Vector**: 12 bytes randomly generated per packet using OpenSSL RAND_bytes

**Authentication Tag**: 16 bytes appended to ciphertext by GCM mode

**Encryption Process**

1. Generate random 12-byte IV
2. Initialize AES-256-GCM cipher with session key and IV
3. Encrypt plaintext payload
4. Obtain 16-byte GCM authentication tag
5. Append tag to ciphertext
6. Store IV in packet header

**Decryption Process**

1. Extract IV from packet header
2. Initialize AES-256-GCM cipher with session key and IV
3. Separate last 16 bytes as authentication tag
4. Decrypt ciphertext (without tag)
5. Verify authentication tag matches
6. Reject packet if tag verification fails

**Security Properties**

- Confidentiality: AES-256 provides strong encryption
- Authenticity: GCM tag proves data origin
- Integrity: Tag verification detects any tampering
- Uniqueness: Random IV prevents pattern analysis

**Critical Requirement**: Never reuse IV with same key. Current implementation generates random IV per packet.

---

### HMAC-SHA256 Authentication

**Algorithm**: Hash-based Message Authentication Code with SHA-256

**Key Source**: 32-byte session_token from header

**Output Length**: 32 bytes (256 bits)

**Authenticated Data**

The HMAC covers two components in order:
1. Complete 80-byte packet header
2. Complete encrypted payload including GCM tag

**HMAC Computation Process**

1. Initialize HMAC context with SHA256 algorithm
2. Set HMAC key to session_token (32 bytes)
3. Update HMAC with header bytes (80 bytes)
4. Update HMAC with encrypted payload bytes
5. Finalize HMAC to produce 32-byte result

**HMAC Verification Process**

1. Compute HMAC over received packet
2. Compare computed HMAC with packet HMAC field
3. Reject packet if HMACs do not match exactly

**Why Both GCM and HMAC**

GCM authentication tag protects payload only. HMAC protects entire packet including header. This prevents attacks where header fields (command, nonce, etc.) are modified while keeping valid payload.

**Defense in Depth**: Two independent authentication mechanisms provide stronger security than either alone.

---

### Anti-Replay Protection

**Mechanism**: Monotonically increasing nonce per session

**Nonce Generation**

Value combines two sources:
1. Current time in milliseconds since epoch
2. Random value from C standard library rand()

Formula: nonce = current_time_milliseconds + rand()

**Server-Side Validation**

For each session, server tracks last_nonce value. When packet arrives:

1. Check if packet nonce > last_nonce
2. If yes: Accept packet, update last_nonce to packet nonce
3. If no: Reject packet as replay attack

**Properties**

- Prevents replaying old packets
- Requires reasonably synchronized clocks (within ~1 second tolerance)
- Random component prevents prediction
- Per-session tracking allows concurrent sessions

**Limitation**: If client clock is significantly behind server, all packets may be rejected. Client should use NTP or similar for time synchronization.

---

### Session Expiration

**Default Lifetime**: 1 hour from creation

**Enforcement Point**: Server validates expiration on every received packet before processing

**Expiration Check**

1. Compare current server time with session expiry timestamp
2. If current time > expiry time: Remove session, reject packet
3. If current time <= expiry time: Process packet normally

**Cleanup**: Expired sessions are removed from server table to prevent memory leaks

**Token Renewal**: Current protocol does not support extending expiration. Client must open new session when current expires.

**Security Benefit**: Limits damage from token compromise. Stolen token becomes useless after expiration.

---

## Error Handling

### Client-Side Error Detection

**Connection Failure**

Detected when socket connection attempt fails. Common causes: server offline, network issue, firewall blocking.

**Read Timeout**

Detected when socket read operation exceeds timeout period. Indicates server not responding or network latency.

**Magic Value Mismatch**

Detected when packet header magic field does not equal expected value 0xDEADFADB. Indicates:
- Protocol version incompatibility
- Corrupted data stream
- Invalid packet format

**HMAC Verification Failure**

Detected when computed HMAC does not match received HMAC. Indicates:
- Packet tampering during transmission
- Corrupted data
- Wrong session token used
- Network corruption

**Decryption Failure**

Detected when GCM tag verification fails during decryption. Indicates:
- Encrypted payload tampering
- Corrupted ciphertext
- Wrong session key
- Wrong IV

**Recommended Actions**

- Log error with details for debugging
- Close socket connection
- Retry with new connection if transient error
- Report to user if persistent error

---

### Server-Side Error Responses

All command processing errors result in CMD_GENERIC_ACK response with appropriate AckType.

**ERROR_TGAPI_EXCEPTION**

Cause: Telegram Bot API rejected operation  
Examples: Invalid chat ID, bot blocked by user, insufficient permissions  
Client Action: Check chat ID validity, verify bot permissions

**ERROR_INVALID_ARGUMENT**

Cause: Command parameters do not meet requirements  
Examples: Malformed JSON, wrong struct size, missing required field  
Client Action: Validate payload before sending, check struct alignment

**ERROR_COMMAND_IGNORED**

Cause: Server policy rejected command  
Examples: File already exists (overwrite=false), chat already observed, resource unavailable  
Client Action: Adjust command parameters, check current state before retrying

**ERROR_RUNTIME_ERROR**

Cause: Internal server error during processing  
Examples: File I/O error, out of memory, database failure  
Client Action: Retry after delay, report persistent errors

**ERROR_CLIENT_ERROR**

Cause: Client violated protocol requirements  
Examples: Expired session token, replay attack detected, invalid nonce  
Client Action: Open new session, check system clock synchronization

---

## Implementation Notes

### Structure Size Requirements

All binary structures must match exact sizes due to direct memory mapping. Compile-time assertions enforce these requirements.

**Enforced Sizes**

| Structure Name | Required Size | Components |
|----------------|---------------|------------|
| Packet::Header | 80 bytes | Magic(8) + Cmd(4) + DataType(4) + DataSize(4) + Token(32) + Nonce(8) + IV(12) + Padding(8) |
| WriteMsgToChatId | 264 bytes | Chat(8) + Message(256) |
| ObserveChatId | 16 bytes | Chat(8) + Observe(1) + Padding(7) |
| SendFileToChatId | 272 bytes | Chat(8) + FileType(4) + FilePath(256) + Padding(4) |
| ObserveAllChats | 8 bytes | Observe(1) + Padding(7) |
| FileTransferMeta | 552 bytes | SrcPath(256) + DestPath(256) + Hash(32) + Options(3) + Padding(5) |
| GetUptimeCallback | 24 bytes | Uptime(24) |
| GenericAck | 264 bytes | Result(4) + ErrorMsg(256) + Padding(4) |

**Size Mismatch Handling**: If received struct size does not match expected size, server returns ERROR_INVALID_ARGUMENT.

---

### Protocol Constants

**String Sizes** (from `api/CoreTypes.hpp`)

- MAX_PATH_SIZE: 256 bytes for file paths
- MAX_MSG_SIZE: 256 bytes for message text

**Alignment** (from `api/CoreTypes.hpp`)

- ALIGNMENT: 8 bytes for all structures

**Cryptography** (from `api/CoreTypes.hpp::Crypto`)

- IV_LENGTH: 12 bytes for AES-GCM initialization vector
- TAG_LENGTH: 16 bytes for GCM authentication tag
- SESSION_TOKEN_LENGTH: 32 bytes for session key

**Protocol Version** (from `api/CoreTypes.hpp::Protocol`)

- MAGIC_VALUE_BASE: 0xDEADFACE
- DATA_VERSION: 13
- MAGIC_VALUE: 0xDEADFADB (MAGIC_VALUE_BASE + DATA_VERSION)

**Special Markers** (from `api/DataStructures.hpp`)

- JSON_BYTE_BORDER: 0xFF byte separating JSON metadata from binary file data

---

### Memory Management

**SharedMalloc**: Custom smart pointer class managing packet payload memory. Provides reference counting and automatic cleanup.

**RAII Wrappers**: OpenSSL context objects wrapped in unique_ptr with custom deleters. Ensures contexts are freed even if exceptions occur.

**Alignment Requirements**: All structures aligned to 8-byte boundaries for optimal CPU access and cross-platform compatibility.

**Buffer Allocation**: Encrypted payload buffer size includes original data plus 16-byte GCM tag. Always allocate: plaintext_size + 16 bytes.

---

## Best Practices

### Essential Security Practices

**Magic Value Validation**: Always verify magic value before processing any packet. Reject mismatches immediately to avoid processing invalid data.

**HMAC Verification First**: Always verify HMAC before attempting decryption. Prevents wasting CPU cycles on tampered packets.

**Nonce Checking**: Always validate nonce increases monotonically. Essential for replay attack prevention.

**IV Generation**: Always generate cryptographically random IV per packet. Never reuse IVs or use predictable values.

**Session Cleanup**: Always send CMD_CLOSE_SESSION before disconnecting. Allows server to free resources promptly.

---

### Development Practices

**Format Selection**: Use JSON during development and debugging for human readability. Use Binary in production for performance and compact size.

**Error Handling**: Handle all AckType error values in client code. Log errors appropriately for troubleshooting.

**Socket Timeouts**: Set reasonable timeout values (5-10 seconds) for socket read operations. Prevents indefinite blocking on network issues.

**Logging Levels**: Log protocol violations at debug level, not error level. Replay attacks and expired sessions are expected in hostile environments.

**Token Management**: Implement token refresh logic if sessions may exceed 1 hour. Currently requires opening new session when expired.

---

### Performance Considerations

**Payload Format Choice**: Binary format provides better performance due to:
- No JSON parsing overhead
- Smaller payload size
- Direct memory mapping
- Faster serialization/deserialization

**Connection Reuse**: Reuse socket connections when possible. Opening new connections has overhead of TCP handshake plus session establishment.

**Batch Operations**: Group multiple commands into single session to amortize connection overhead.

---

## References

### Standards and Specifications

**OpenSSL EVP API Documentation**  
URL: https://www.openssl.org/docs/man3.0/man7/evp.html  
Description: Envelope encryption/decryption interface used for AES-GCM operations

**AES-GCM Specification**  
Document: NIST Special Publication 800-38D  
Description: Galois/Counter Mode specification for authenticated encryption

**HMAC Specification**  
Documents: RFC 2104, FIPS 198-1  
Description: Keyed-Hash Message Authentication Code algorithm

**SHA-256 Specification**  
Document: FIPS 180-4  
Description: Secure Hash Algorithm producing 256-bit digests

**Telegram Bot API**  
URL: https://core.telegram.org/bots/api  
Description: Telegram Bot API methods and types used by server

---

**Document Information**

- Document Version: 1.1
- Last Updated: December 22, 2024
- Protocol Version: 13
- Compatibility: C++23, C++17
- Build System: CMake 3.14+ with Ninja generator

---
